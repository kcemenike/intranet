import { ConditionContract} from './condition.contract'
import { FilterContract } from './filter.contract'

export enum QueryActions {
    get 	=	'get',
    first 	= 'first',
    value 	= 'value',
    pluck 	= 'pluck',
    exists 	= 'exists',
    doesntExist	= 'doesntExist',
    where 	= 'where',
    orWhere 	= 'orWhere',
    whereBetween 	= 'whereBetween',
    whereNotBetween 	= 'whereNotBetween',
    whereIn 	= 'whereIn',
    whereNotInwhereNull 	= 'whereNotInwhereNull',
    whereNotNull 	= 'whereNotNull',
    whereDate 	= 'whereDate',
    whereMonth 	= 'whereMonth',
    whereDay 	= 'whereDay',
    whereYear 	= 'whereYear',
    whereTime 	= 'whereTime',
    whereColumn	= 'whereColumn',
    orderBy 	= 'orderBy',
    groupBy 	= 'groupBy',
    distinct 	= 'distinct',
    latest = 'latest',
    oldest 	= 'oldest',
    inRandomOrder 	= 'inRandomOrder',
    skip	= 'skip',
    take 	= 'take',
    limit 	= 'limit',
    offset	= 'offset',
    chunk	= 'chunk',
    count 	= 'count',
    max 	= 'max',
    min 	= 'min',
    avg 	= 'avg',
    sum	= 'sum',
    firstOrFail 	= 'firstOrFail',
    findOrFail 	= 'findOrFail',
    withTrashed	= 'withTrashed',
    all	= 'all',
    average	= 'average',
    // avg	=	    // 'avg',
    // chunk	=	    // 'chunk',
    collapse	= 'collapse',
    combine	= 'combine',
    concat	= 'concat',
    contains	= 'contains',
    containsStrict	= 'containsStrict',
    // count	=	    // 'count',
    crossJoin	= 'crossJoin',
    dd	= 'dd',
    diff	= 'diff',
    diffKeys	= 'diffKeys',
    dump	= 'dump',
    each	= 'each',
    eachSpread	= 'eachSpread',
    every	= 'every',
    except	= 'except',
    filter	= 'filter',
    // first	=	    // 'first',
    flatMap	= 'flatMap',
    flatten	= 'flatten',
    flip	= 'flip',
    forget	= 'forget',
    forPage	= 'forPage',
    // get	=	    // 'get',
    // groupBy	=	    // 'groupBy',
    has	= 'has',
    implode	= 'implode',
    intersect	= 'intersect',
    isEmpty	= 'isEmpty',
    isNotEmpty	= 'isNotEmpty',
    keyBy	= 'keyBy',
    keys	= 'keys',
    last	= 'last',
    map	= 'map',
    mapInto	= 'mapInto',
    mapSpread	= 'mapSpread',
    mapToGroups	= 'mapToGroups',
    mapWithKeys	= 'mapWithKeys',
    // max	=	    // 'max',
    median	= 'median',
    merge	= 'merge',
    // min	=	    // 'min',
    mode	= 'mode',
    nth	= 'nth',
    only	= 'only',
    pad	= 'pad',
    partition	= 'partition',
    pipe	= 'pipe',
    // pluck	=	    // 'pluck',
    pop	= 'pop',
    prepend	= 'prepend',
    pull	= 'pull',
    push	= 'push',
    put	= 'put',
    random	= 'random',
    reduce	= 'reduce',
    reject	= 'reject',
    reverse	= 'reverse',
    search	= 'search',
    shift	= 'shift',
    shuffle	= 'shuffle',
    slice	= 'slice',
    sort	= 'sort',
    sortBy	= 'sortBy',
    sortByDesc	= 'sortByDesc',
    splice	= 'splice',
    split	= 'split',
    // sum	=	    // 'sum',
    // take	=	    // 'take',
    tap	= 'tap',
    toArray	= 'toArray',
    toJson	= 'toJson',
    transform	= 'transform',
    union	= 'union',
    unique	= 'unique',
    uniqueStrict	= 'uniqueStrict',
    unless	= 'unless',
    values	= 'values',
    when	= 'when',
    // where	=	    // 'where',
    whereStrict	= 'whereStrict',
    // whereIn	=	    // 'whereIn',
    whereInStrict	= 'whereInStrict',
    whereNotIn	= 'whereNotIn',
    whereNotInStrict	= 'whereNotInStrict',
    zip	= 'zip'
};

export interface QueryActionsContract{
    [actioName: string]: (string|boolean)[]; // actionName: [...args]
};

// db?: string;
// table?: string;
// columns?: string;
// actions:

export interface QueryContract{
    conditions?: ConditionContract;
    filters?: FilterContract[];
    forClientStore?: { [key: string]: string }
    forRemoteStore?: any;
    forWebStore?: any;
}
